# -*- coding: utf-8 -*-
"""asset_analyzer_func.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r7l3RmzdCbkZolOrvpwxVrdPgTCyt9Z_

# Asset Analyzer
Module with all the funtions.  
My Website: https://aadsm2355.wixsite.com/andryadsm

# Packages
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf

"""# Download Data
- download_data
"""

def download_data(
        tickers:     list[str],
        start:       str | None,
        end:         str | None,
        interval:    str  = '1d',
        *,
        actions:     bool = False,
        auto_adjust: bool = False
) -> pd.DataFrame:
    """
        Downloads price and volume data for each ticker from Yahoo Finance.
        #### return pd.DataFrame

        Params
        ---
        - tickers: list
            List of tickers to download.
        - start: str
            The start date formatted as 'YYYY-MM-DD', inclusive.
            If None, defaults to the maximum available time.
        - end: str
            The end date formatted as 'YYYY-MM-DD', exclusive.
            If None, defaults to the
        - interval: str='1d'
            Valid intervals:
                '1m', '2m', '5m', '15m', '30m', '60m', '90m', '1h', '1d', '5d', '1wk', '1mo' or '3mo'.
            intraday data cannot extend last 60 days,
            except '60m' or '1h', up to last 730 days (1.5 years)
            and '1m', up to last 7 days (1 week)
        - actions: bool=False
            Download dividend & stock splits data.
        - auto_adjust: bool=False
            Adjusts all OHLC automatically.

        Example use
        ---
        `tickers = ['SPY', 'AAPL', 'TSLA', 'KO']`
        `data = aa.download_data(tickers, '2023-01-01', '2024-01-01', '1d')`
    """

    data = yf.download(tickers,
                       start=start,
                       end=end,
                       group_by='ticker',
                       interval=interval,
                       actions=actions,
                       auto_adjust=auto_adjust)

    if len(tickers) == 1:
        data.columns = pd.MultiIndex.from_product([tickers, data.columns],
                                                  names=['Ticker', 'Price'])
    return data[tickers]

# tickers = ['SPY', 'AAPL', 'TSLA', 'KO']
# data = download_data(tickers, '2023-01-01', '2024-01-01', '1d')
# data

"""# Get Data
- pct_returns
- pct_returns_daily
- insights
- top_results
- normalize_values
"""

def pct_returns(
        data:      pd.DataFrame,
        values:    dict | None = None,
        *,
        round_val: int  = 6,
        as_pct:    bool = True
) -> pd.DataFrame:
    """
        Gets percentage return for the specified time frames.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - values: dict | None=None
            Takes dictionary in the form {str: (str, str, int)}
            notation {'Name_of_return': ('After_price', 'Before_price', shift_of_before_price)}
            if None, defaults to {'Daily': ('Close', 'Close', 1)}
        - round_val: int=6
            Number of decimals to be rounded to.
        - as_pct: bool=True
            If True, values are expressed as percentages (e.g. 1.23 (%)),
            if False, as decimals (e.g. 0.0123).

        Example use
        ---
        `data_ret = aa.pct_returns(data, values={'O_to_C': ('Close', 'Open' , 0), 'HL_diff': ('High' , 'Low'  , 0)}, round_val=2)`
    """

    if values is None:
        values = {'Daily': ('Close', 'Close', 1)}

    data_ret = pd.DataFrame(index=data.index,
                            columns=pd.MultiIndex.from_product([[], []],
                                                               names=['Ticker', 'TimeFrame']))

    for tk in data.columns.get_level_values(0).unique():
        if tk != 'Datetime':
            # General formula
            for key, val in values.items():
                after, before, shift = val
                data_ret[tk, f'{key}'] = (data[tk, after] - data[tk, before].shift(shift)) \
                                        / data[tk, before].shift(shift) * 100

    data_ret = data_ret.round(round_val)

    # Turn percentage into decimal
    if as_pct is False:
        data_ret /= 100

    return data_ret

# data_ret = pct_returns(data,
#                        values={'Daily':    ('Close', 'Close', 1),
#                                'Intraday': ('Close', 'Open' , 0),
#                                'HL_diff':  ('High' , 'Low'  , 0)})
# data_ret.head(10)

def pct_returns_daily(
        data:      pd.DataFrame,
        *,
        round_val: int  = 6,
        as_pct:    bool = True
) -> pd.DataFrame:
    """
        Gets percentage return for different time frames for daily price data.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data of interval '1d'
        - round_val: int=6
            Number of decimals to be rounded to.
        - as_pct: bool=True
            If True, values are expressed as percentages (e.g. 1.23 (%)),
            if False, as decimals (e.g. 0.0123).

        Example use
        ---
        `data_ret_d = aa.pct_returns_daily(data)`
    """

    values = {'Intraday':  ('Close', 'Open' , 0 ),
              'Overnight': ('Open' , 'Close', 1 ),
              'Daily':     ('Close', 'Close', 1 ),
              '1week':     ('Close', 'Close', 5 ),
              '2week':     ('Close', 'Close', 10),
              '3week':     ('Close', 'Close', 15),
              '4week':     ('Close', 'Close', 20)}

    data_ret = pct_returns(data=data,
                           values=values,
                           round_val=round_val,
                           as_pct=as_pct)
    return data_ret

# data_ret_d = pct_returns_daily(data)
# data_ret_d.head(10)

def insights(
        data_ret:   pd.DataFrame,
        *,
        volatility: bool = True,
        mean:       bool = True,
        mean_abs:   bool = True,
        order_by:   str  = 'ins'
) -> pd.DataFrame:
    """
        Gets insights like volatility, mean and mean of absolute values
        about the returns data.
        #### return pd.DataFrame

        Params
        ---
        - data_ret: pd.DataFrame
            Takes returns data,
            can get it with the pct_returns() function.
        - volatility: bool=True
            If to include the volatility measure.
        - mean: bool=True
            If to include the mean measure.
        - mean_abs: bool=True
            If to include the mean of the absolute values measure.
        - order_by: str='ins'
            If 'ins', order the index by insights,
            if 'ret', order by return.

        Example use
        ---
        `data_ins = aa.insights(data_ret, order_by='ins')`
    """

    data_ins = pd.DataFrame(columns=pd.MultiIndex.from_product([[], []],
                                                               names=['Insight', 'Return']))

    tks = data_ret.columns.get_level_values(0).unique()
    ret = data_ret.columns.get_level_values(1).unique()

    for col in ret:
        if volatility:
            data_ins['Volatility', f'{col}'] = {tk: (data_ret[tk, col].std()) for tk in tks}
        if mean:
            data_ins['Mean', f'{col}'] = {tk: data_ret[tk, col].mean() for tk in tks}
        if mean_abs:
            data_ins['Mean_abs', f'{col}'] = {tk: data_ret[tk, col].abs().mean() for tk in tks}

    data_ins = data_ins.T
    data_ins = data_ins.loc[data_ins.index.get_level_values(0).unique()]

    if order_by == 'ret':
        data_ins = data_ins.swaplevel('Return', 'Insight').loc[ret]
        return data_ins
    return data_ins

# data_ins = insights(data_ret)
# data_ins

def top_results(
        data_ins:  pd.DataFrame,
        *,
        top:       int = 3,
        bot:       int = 3,
        round_val: int = 6
) -> None:
    """
        Displays the top and bottom results of the insights data.
        #### return None

        Params
        ---
        - data_ins: pd.DataFrame
            Takes insights data,
            can get it with the insights() function.
        - top: int=3
            Top n to display.
        - bot: int=3
            Bottom n to display.
        - round_val: int=6
            Number of decimals to be rounded to.

        Example use
        ---
        `aa.top_results(data_ins, top=2, bot=1, round_val=3)`
    """

    for i in data_ins.index:
        display(pd.DataFrame(
            [data_ins.loc[i].nlargest(top).round(round_val),
             data_ins.loc[i].nsmallest(bot).round(round_val).sort_values(ascending=False)],
            index=[f'Top {i[0]}, {i[1]}', f'Bottom {i[0]}, {i[1]}']
        ))

# top_results(data_ins, top=2, bot=1, round_val=3)

def normalize_values(
        data:   pd.DataFrame,
        *,
        volume: bool = True
) -> pd.DataFrame:
    """
        Gets normalized price and volume data.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price and volume data.
        - volume: bool=True
            If to include normalized volume data

        Example use
        ---
        `data_norm = aa.normalize_values(data)`
    """

    data_norm = pd.DataFrame(columns=pd.MultiIndex.from_product([[], []],
                                                                names=['Ticker', 'Price']))

    tks = [tk for tk in data.columns.get_level_values(0).unique() if tk != 'Datetime']
    prices = [price for price in data.columns.get_level_values(1).unique() \
              if price in ['Open', 'High', 'Low', 'Close', 'Adj Close']]

    # Calculate min and max price across all prices for each ticker
    min_price = {tk: data[tk][prices].min().min() for tk in tks}
    max_price = {tk: data[tk][prices].max().max() for tk in tks}

    # Normalize between 0 and 1
    for tk in tks:
        for price in prices:
            data_norm[tk, f'{price}_norm']  = (data[tk, price]  - min_price[tk]) \
                                              / (max_price[tk] - min_price[tk])

        if volume and 'Volume' in data.columns.get_level_values(1).unique():
            vol = data[tk, 'Volume']
            data_norm[tk, 'Volume_norm'] = (vol - vol.min()) \
                                           / (vol.max() - vol.min())

    return data_norm

# data_norm = normalize_values(data)
# data_norm

"""# Drop Columns, Get Date Values
- drop_columns
- from_datetime
"""

def drop_columns(
        data: pd.DataFrame,
        cols: str | list[str],
        *,
        inplace: bool = False
) -> pd.DataFrame:
    """
        Drops all the columns specified out of the second level.
        Similar to using the pandas drop() method.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Data where the columns are going to be dropped.
        - cols: str | list[str]
            Labels of columns to be dropped.
        - inplace: bool=False
            If False, return a copy,
            if True, do operation inplace (overwrite).

        Example use
        ---
        `data_drop = aa.drop_columns(data, 'Adj Close')`
    """

    # To be able to input a string
    if type(cols) is str:
        cols = [cols]

    # To overwrite
    if inplace:
        data.drop(columns=cols, inplace=True, level=1, errors='ignore')
    # Not to overwrite
    else:
        data = data.drop(columns=cols, level=1, errors='ignore')

    return data

# data_drop = drop_columns(data, 'Adj Close')
# data_drop

def from_datetime(
        data:   pd.DataFrame,
        get:    str,
        *,
        add_col: bool = False
) -> pd.DataFrame:
    """
        Get a DataFrame with the datetime value gotten from the index.
        Can concatenate with the source DataFrame.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes data with DatetimeIndex as index.
        - get: str
            The value to get from the datetime index.
            Valid inputs are:
                'minute', 'hour', 'weekday', 'day_name', 'day', 'month', 'month_name', 'quarter' or 'year'
        - add_col: bool=False
            If to add a Datetime column to the source data.

        Example use
        ---
        `data_date = aa.from_datetime(data, 'weekday', add_col=True)`
    """

    # Check if the input for get is valid
    inputs = ['minute', 'hour', 'weekday', 'day_name',
              'day', 'month', 'month_name', 'quarter', 'year']

    if get not in inputs:
        raise ValueError(f'Invalid input, get=\'{get}\', valid inputs are: {inputs}')

    # Check if the column already exist
    if add_col and f'{get.capitalize()}' in data.columns.get_level_values(1).unique():
        raise Exception(f'Already a column named \'{get}\'.')

    dt = data.index.to_frame().iloc[:,0].dt

    # Get the actual datetime
    if 'name' in get:
        dt = eval(f'dt.{get}()')
    else:
        dt = eval(f'dt.{get}')

    if add_col:
        df = data.copy()
        df[('Datetime', f'{get.capitalize()}')] = dt
        return df
    else:
        dt = dt.to_frame()
        dt.columns = [f'{get.capitalize()}']
        return dt

# data_date = from_datetime(data, 'weekday', add_col=True)
# data_date

"""# Plots
- plot_price
- plot_volume
- plot_price_vol
- plot_norm_moves
- plot_norm_vol
- plot_dist_ret
"""

def plot_price(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        style:     str                 = 'dark_background',
        figsize:   tuple[float] | None = None,
        use_price: str                 = 'Close',
        color:     str                 = 'c',
        mas:       list[int] | bool    = True,
        mas_color: list[str] | None    = None,
        legendloc: str | None          = None
) -> None:
    """
        Plots the price and moving averages of a specific ticker.
        #### return None

        Params
        ---
        - data: pd.DataFrame
            Takes price data with no modifications.
        - ticker: str
            The ticker to plot.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - use_price: str='Close'
            The price column to be used for plotting the price.
        - color: str='cyan'
            Color of the price line.
        - mas: list[str] | None=None
            Length of price moving averages, as many as wished,
            if None, defaults to 20, 40, 100 and 200
        - mas_color: list[str] | None=None
            Color of each of the price moving averages in order,
            if None, defaults to a palette.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_price(data, 'SPY', color='w', mas=[20, 50, 100, 150])`
    """

    # Prepare data to be plotted
    date_format = '%Y-%m-%d'
    if data.index.name == 'Datetime':
        date_format = '%Y-%m-%d %H:%M'
    data_to_plot = data.loc[start:end][ticker]
    data_to_plot.index = data_to_plot.index.strftime(date_format)
    data_ma = data[ticker]
    data_ma.index = data_ma.index.strftime(date_format)

    # Plot
    with plt.style.context(style):
        if figsize is None:
            figsize = (16, 6)

        plt.figure(figsize=figsize)
        plt.title(f'{ticker} Price', size=18)

        # Price
        plt.plot(data_to_plot[use_price],
                 color=color,
                 linewidth=2,
                 zorder=20,
                 label=f'{use_price} Price')

        # Price Moving Averages
        if mas is not False:
            if mas is True:
                mas = [20, 40, 100, 200]
            if mas_color is None:
                 mas_color = ['y', 'r', 'g', 'm']

            for m, c, z in zip(mas,
                               range(len(mas_color)+100),
                               range(len(mas)-1, -1, -1)):
                plt.plot(data_ma[use_price].rolling(m).mean().loc[start:end],
                         color=mas_color[c % len(mas_color)],
                         zorder=z,
                         label=f'{m}MA')

        plt.grid(which='major', color='grey', linestyle=':')
        plt.xticks(np.arange(len(data_to_plot),
                             step=max(len(data_to_plot) // 10, 1)),
                   size=7)
        plt.legend(loc=legendloc)
        plt.xlabel('Date')
        plt.ylabel('Price ($)')
        plt.show()

# plot_price(data, 'SPY')

def plot_volume(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        style:     str                 = 'dark_background',
        figsize:   tuple[float] | None = None,
        bar_color: str | None          = None,
        ma:        int | bool          = True,
        ma_color:  str                 = 'y',
        legendloc: str | None          = None
) -> None:
    """
        Plots volume and a moving average of a specific ticker.
        #### return None

        Params
        ---
        - data: pd.DataFrame
            Takes volume data with no modifications,
            Column name must be 'Volume'
        - ticker: str
            The ticker to plot.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - bar_color: str=None
            Color of the volume bars,
            if None, defaults to color based on the movement of each interval.
        - ma: int | bool=True
            Length of the volume moving average, only one.
            If False, do not show moving average,
            if True, defaults to a 20 moving average.
        - ma_color: str='orange'
            Color of the volume moving average line.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_volume(data, 'SPY', ma=50)`
    """

    # Prepare data to be plotted
    date_format = '%Y-%m-%d'
    if data.index.name == 'Datetime':
        date_format = '%Y-%m-%d %H:%M'
    data_to_plot = data.loc[start:end][ticker]
    data_to_plot.index = data_to_plot.index.strftime(date_format)
    data_ma = data[ticker]
    data_ma.index = data_ma.index.strftime(date_format)

    # Plot
    with plt.style.context(style):
        if figsize is None:
            figsize = (16, 6)

        plt.figure(figsize=figsize)
        plt.title(f'{ticker} Volume', size=18)

        # Color vol bars based on if the price went up or down in that interval
        if bar_color is None:
            period_ret = (data_ma['Close'] - data_ma['Open']) \
                         / data_ma['Open'] * 100
            colors = ['r' if ret < 0 else 'g' for ret in period_ret]
            bar_color = pd.Series(colors,
                                index=period_ret.index
                                ).loc[start:end]

        # Plot volume bars
        plt.bar(x=data_to_plot.index,
                height=data_to_plot['Volume'],
                color=bar_color,
                edgecolor=bar_color,
                label='Volume')

        # Volume Moving Average
        if ma is True:
            ma = 20
        if ma is not False:
            plt.plot(data_ma['Volume'].rolling(ma).mean().loc[start:end],
                     color=ma_color,
                     label=f'Vol {ma}MA')

        plt.grid(which='major', color='grey', linestyle=':')
        plt.xticks(np.arange(len(data_to_plot),
                             step=max(len(data_to_plot) // 10, 1)),
                   size=7)
        plt.legend(loc=legendloc)
        plt.xlabel('Date')
        plt.ylabel('Volume')

        plt.show()

# plot_volume(data, 'SPY')

def plot_price_vol(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        style:           str                 = 'dark_background',
        figsize:         tuple[float] | None = None,
        use_price:       str                 = 'Close',
        price_color:     str                 = 'c',
        price_mas:       list[int] | bool    = True,
        price_mas_color: list[str] | None    = None,
        vol_bar_color:   str | None          = None,
        volume_ma:       int | bool          = True,
        vol_ma_color:    str                 = 'y',
        legendloc:       str | None          = None
) -> None:
    """
        Plots the price, volume and moving averages of a specific ticker.
        #### return None

        Params
        ---
        - data: pd.DataFrame
            Takes price and volume data with no modifications.
        - ticker: str
            The ticker to plot.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - use_price: str='Close'
            The price column to be used for plotting the price.
        - price_color: str='cyan'
            Color of the price line.
        - price_mas: list[str] | None=None
            Length of price moving averages, as many as wished,
            if None, defaults to 20, 40, 100 and 200
        - price_mas_color: list[str] | None=None
            Color of each of the price moving averages in order,
            if None, defaults to a palette.
        - vol_bar_color: str=None
            Color of the volume bars,
            if None, defaults to color based on the movement of each interval.
        - volume_ma: int | bool=True
            Length of the volume moving average, only one.
            If False, do not show moving average,
            if True, defaults to a 20 moving average.
        - vol_ma_color: str='orange'
            Color of the volume moving average line.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_price_vol(data, 'SPY', price_color='w', price_mas=[20, 50, 100, 150])`
    """

    # Prepare data to be plotted
    date_format = '%Y-%m-%d'
    if data.index.name == 'Datetime':
        date_format = '%Y-%m-%d %H:%M'
    data_to_plot = data.loc[start:end][ticker]
    data_to_plot.index = data_to_plot.index.strftime(date_format)
    data_ma = data[ticker]
    data_ma.index = data_ma.index.strftime(date_format)

    # Plot
    with plt.style.context(style):
        if figsize is None:
            figsize = (16, 6)

        fig, axs = plt.subplots(2,
                                figsize=(figsize),
                                height_ratios=(5, 2),
                                sharex=True)
        plt.suptitle(f'{ticker} Price and Volume', size=18)
        plt.subplots_adjust(hspace=0.1)

        # Price
        axs[0].plot(data_to_plot[use_price],
                    color=price_color,
                    linewidth=2,
                    zorder=20,
                    label=f'{use_price} Price')

        # Price Moving Averages
        if price_mas is not False:
            if price_mas is True:
                price_mas = [20, 40, 100, 200]
            if price_mas_color is None:
                price_mas_color = ['y', 'r', 'g', 'm']

            for m, c, z in zip(price_mas,
                            range(len(price_mas_color)+100),
                            range(len(price_mas)-1, -1, -1)):
                axs[0].plot(data_ma[use_price].rolling(m).mean().loc[start:end],
                            color=price_mas_color[c % len(price_mas_color)],
                            zorder=z,
                            label=f'{m}MA')

        axs[0].grid(which='major', color='grey', linestyle=':')
        axs[0].set_ylabel('Price ($)')
        axs[0].legend(loc=legendloc)

        # Volume
        # Color vol bars based on if the price went up or down in that interval
        if vol_bar_color is None:
            period_ret = (data_ma['Close'] - data_ma['Open']) \
                            / data_ma['Open'] * 100
            colors = ['r' if ret < 0 else 'g' for ret in period_ret]
            vol_bar_color = pd.Series(colors,
                                index=period_ret.index
                                ).loc[start:end]

        # Plot volume bars
        axs[1].bar(x=data_to_plot.index,
                    height=data_to_plot['Volume'],
                    color=vol_bar_color,
                    edgecolor=vol_bar_color,
                    label='Volume')

        # Volume Moving Average
        if volume_ma is True:
            volume_ma = 20
        if volume_ma is not False:
            axs[1].plot(data_ma['Volume'].rolling(volume_ma).mean().loc[start:end],
                        color=vol_ma_color,
                        label=f'Vol {volume_ma}MA')

        axs[1].grid(which='major', color='grey', linestyle=':')
        axs[1].set_ylabel('Volume')
        axs[1].legend(loc=legendloc)

        plt.xticks(np.arange(len(data_to_plot),
                            step=max(len(data_to_plot) // 10, 1)),
                size=7)
        plt.xlabel('Date')

        plt.show()

# plot_price_vol(data, 'SPY')

def plot_norm_moves(
        data_norm: pd.DataFrame,
        tickers:   list[str] | None  = None,
        start:     str | None        = None,
        end:       str | None        = None,
        *,
        style:     str               = 'dark_background',
        figsize:   tuple[int] | None = None,
        use_price: str               = 'Close_norm',
        colors:    list[str] | None  = None,
        legendloc: str | None        = None
) -> None:
    """
        Plots movement of normalized prices,
        compare movements between assets by giving more than one ticker.
        #### return None

        Params
        ---
        - data_norm: pd.DataFrame
            Takes normalized price data,
            can get it with the normalize_values() function.
        - ticker: list[str] | None=None
            The tickers to plot,
            if None, default to plot all.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - use_price: str='Close_norm'
            The normalized price column to be used for plotting the price.
        - colors: list[str] | None=None
            List with the color of each line in order,
            if None, defaults to a palette.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_norm_moves(data_norm, ['SPY', 'AAPL'], colors=['w', 'r'])`
    """

    # Prepare data to be plotted
    if tickers is None:
        tickers = data_norm.columns.get_level_values(0).unique()
    date_format = '%Y-%m-%d'
    if data_norm.index.name == 'Datetime':
        date_format = '%Y-%m-%d %H:%M'
    data_to_plot = data_norm.loc[start:end][tickers]
    data_to_plot.index = data_to_plot.index.strftime(date_format)

    if colors is None:
        colors = ['r', 'b', 'g', 'y', 'm', 'c']
    if figsize is None:
        figsize = (16, 6)

    # Plot
    with plt.style.context(style):
        plt.figure(figsize=figsize)
        plt.title('Movement Normalized', size=18)

        for i, tk in enumerate(tickers):
            plt.plot(data_to_plot[tk, use_price],
                     color=colors[i % len(colors)],
                     alpha=1,
                     label=tk)

        plt.grid(which='major', color='grey', linestyle=':')
        plt.xticks(np.arange(len(data_to_plot),
                             step=max(len(data_to_plot) // 10, 1)),
                   size=7)
        plt.legend(loc=legendloc)
        plt.xlabel('Date')
        plt.ylabel(f'{use_price.split("_")[0]} Price Normalized')
        plt.show()

# plot_norm_moves(data_norm)

def plot_norm_vol(
    data_norm: pd.DataFrame,
    tickers:   list[str] | None  = None,
    start:     str | None        = None,
    end:       str | None        = None,
    *,
    style:     str               = 'dark_background',
    figsize:   tuple[int] | None = None,
    colors:    list[str] | None  = None,
    legendloc: str | None        = None
) -> None:
    """
        Plots movement of the normalized volume,
        compare movements between assets by giving more than one ticker.
        #### return None

        Params
        ---
        - data_norm: pd.DataFrame
            Takes normalized volume data,
            can get it with the normalize_values() function.
            Column name must be 'Volume_norm'
        - tickers: list[str] | None= None
            The tickers to be plotted, maximum of three,
            if None, defaults to plot the first three tickers.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD' or 'YYYY-MM-DD hh:mm', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - colors: list[str] | None=None
            List with the color of each line in order,
            if None, defaults to a palette.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_norm_vol(data_norm, ['SPY', 'AAPL'], colors=['w', 'r'])`
    """

    # Prepare data to be plotted
    if tickers is None:
        tickers = data_norm.columns.get_level_values(0).unique()[:3]
    date_format = '%Y-%m-%d'
    if data_norm.index.name == 'Datetime':
        date_format = '%Y-%m-%d %H:%M'
    data_to_plot = data_norm.loc[start:end][tickers]
    data_to_plot.index = data_to_plot.index.strftime(date_format)

    if colors is None:
        colors = ['r', 'b', 'g']
    if figsize is None:
        figsize = (16, 6)

    # Plot
    with plt.style.context(style):
        plt.figure(figsize=figsize)
        plt.title('Volume Normalized', size=18)

        for ticker, color in zip(tickers, colors):
            plt.plot(data_to_plot[ticker, 'Volume_norm'],
                     label=ticker,
                     color=color)

        plt.grid(which='major', color='grey', linestyle=':')
        plt.xticks(np.arange(len(data_to_plot),
                             step=max(len(data_to_plot) // 10, 1)),
                   size=7)
        plt.legend(loc=legendloc)
        plt.xlabel('Date')
        plt.ylabel('Movement')
        plt.show()

# plot_norm_vol(data_norm)

def plot_dist_ret(
        data_ret:  pd.DataFrame,
        tickers:   list[str] | None  = None,
        start:     str | None        = None,
        end:       str | None        = None,
        *,
        style:     str               = 'dark_background',
        figsize:   tuple[int] | None = None,
        use_ret:   str               = 'Daily',
        colors:    list[str] | None  = None,
        hist:      bool              = True,
        kde:       bool              = True,
        legendloc: str | None        = None
) -> None:
    """
        Plots the distribution of the returns of the given period.
        #### return None

        Params
        ---
        - data_ret: pd.DataFrame
            Takes returns data,
            can get it with the pct_returns() function.
        - tickers: list[str] | None= None
            The tickers to be plotted, maximum of three,
            if None, defaults to plot the first three tickers.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - use_ret: str='Daily'
            The return column to be used for plotting the price.
        - colors: list[str] | None=None
            List with the color of each element in order,
            if None, defaults to a palette.
        - hist: bool=True
            If to show histogram plot.
        - kde: bool=True
            If to show kernel density estimate plot.
        - legendloc: str | None=None
            Location of the legend,
            if None, defaults to the best location.

        Example use
        ---
        `aa.plot_dist_ret(data_ret, ['SPY', 'AAPL'], colors=['w', 'r'], use_ret='Intraday')`
    """

    if tickers is None:
        tickers = data_ret.columns.get_level_values(0).unique()[:3]
    else:
        tickers = tickers[:3]
    data_to_plot = data_ret.loc[start:end][tickers]

    if colors is None:
        colors = ['r', 'b', 'g']
    if figsize is None:
        figsize = (16, 6)

    # Plot
    with plt.style.context(style):
        plt.figure(figsize=figsize)
        plt.title(f'Distribution of {use_ret} Return', size=18)

        for ticker, color in zip(tickers, colors):
            if hist:
                sns.histplot(data_to_plot[ticker,  use_ret],
                             bins=50, color=color,
                             edgecolor=None,
                             alpha=0.5,
                             kde=False,
                             stat="density",
                             zorder=2,
                             label=ticker)

            if kde:
                sns.kdeplot(data_to_plot[ticker,  use_ret],
                            color=color,
                            zorder=2,
                            label=ticker)

        plt.grid(which='major', color='grey', zorder=0, linestyle=':')
        plt.legend(loc=legendloc)
        plt.xlabel(f'{use_ret} Return')
        plt.ylabel(f'Density')
        plt.show()

# plot_dist_ret(data_ret)

"""# Calculations
- sharpe_ratio
- correlations
- calc_rsi
- calc_historical_volatility
- calc_bollinger_bands
- calc_macd
- monthly_returns
- hourly_returns
"""

def sharpe_ratio(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price:      str   = 'Close',
        risk_free_rate: float = 0.05
) -> float:
    """
        Calculates the Sharpe Ratio of a ticker.
        #### return float

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - risk_free_rate: float=0.05
            The Risk-Free Rate to use.

        Example use
        ---
        `sharpe_r = aa.sharpe_ratio(data, 'SPY')`
    """

    data_to_use = data.loc[start:end][ticker][use_price]

    returns = data_to_use.pct_change()
    portfolio_return = returns.mean()
    portfolio_volatility = returns.std()

    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility

    return sharpe_ratio

# sharpe_r = sharpe_ratio(data, 'SPY')
# sharpe_r

def correlations(
        data: pd.DataFrame,
        tickers:   list[str] | None = None,
        start:     str | None       = None,
        end:       str | None       = None,
        *,
        use_price: str  = 'Close',
        plot:      bool = True,
        style:     str  = 'dark_background'
) -> pd.DataFrame:
    """
        Calculates the correlation between assets and plots a heatmap.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: list[str] | None=None
            The tickers to use,
            if None, default to use all.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close_norm'
            The normalized price column to be used for plotting the price.
        - plot: bool=True
            If to show the heatmap of the correleations.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`

        Example use
        ---
        `corr_matrix = aa.correlations(data)`
    """

    data_to_use = data.loc[:, pd.IndexSlice[:, use_price]]
    if tickers is None:
        tickers = data_to_use.columns
    data_to_use = data_to_use.loc[start:end][tickers]

    returns = data_to_use.pct_change()

    # Correlation matrix
    corr_matrix = returns.corr()
    corr_matrix.columns = corr_matrix.columns.get_level_values(0)
    corr_matrix.columns.name = None
    corr_matrix.index = corr_matrix.index.get_level_values(0)
    corr_matrix.index.name = None

    # Plot
    if plot:
        with plt.style.context(style):
            plt.title('Correlations', size=18)
            sns.heatmap(corr_matrix,
                        cmap='coolwarm',
                        center=0,
                        annot=True,
                        square=True)
            plt.show()

    return corr_matrix

# corr_matrix = correlations(data)
# corr_matrix

def calc_rsi(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price: str  = 'Close',
        window:    int  = 14,
        add_col:   bool = False,
        plot:      bool = True,
        style:     str  = 'dark_background',
        figsize:   tuple[int] | None = None,
        color:     str  = 'c',
        up_line:   int  = 70,
        lo_line:   int  = 30
) -> pd.DataFrame:
    """
        Calculates the Relative Strength Index (RSI) of a ticker and shows a plot,
        can also get the columns of the data obtained.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - window: int=14
            Window to use for calculations.
        - add_col: bool=False
            If to add columns of the calculations to the source data ticker.
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - color: str='c':
            Color of the RSI line.
        - up_line: int=70
            Place of upper reference line in the plot.
        - lo_line: int=30
            Place of lower reference line in the plot.

        Example use
        ---
        `data_with_calcs = aa.calc_rsi(data, 'SPY', add_col=True)`
    """

    data_to_use = data.loc[start:end][ticker][use_price]

    # Calculate RSI
    delta = data_to_use.diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window).mean()
    avg_loss = loss.rolling(window).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    # Prepare data to be returned
    df = pd.DataFrame()
    df['RSI'] = rsi

    if add_col:
        df.columns = pd.MultiIndex.from_product([[f'{ticker}'], df.columns])
        df = pd.concat([data, df], axis=1)

    if plot:
        # Prepate data to plot
        data_to_plot = rsi
        date_format = '%Y-%m-%d'
        if data_to_plot.index.name == 'Datetime':
            date_format = '%Y-%m-%d %H:%M'
        data_to_plot.index = data_to_plot.index.strftime(date_format)

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} Relative Strength Index (RSI)', size=18)

            plt.plot(data_to_plot, color=color, label='RSI')
            plt.axhline(up_line, color='r', linestyle='--', label=f'Upper  Line ({up_line})')
            plt.axhline(50     , color='b', linestyle='--', label='Middle Line (50)')
            plt.axhline(lo_line, color='g', linestyle='--', label=f'Lower  Line ({lo_line})')

            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.xticks(np.arange(len(data_to_plot),
                                 step=max(len(data_to_plot) // 10, 1)),
                       size=7)
            plt.ylim(0, 100)
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('RSI')
            plt.show()

    return df

# data_with_calcs = calc_rsi(data, 'SPY', add_col=True)
# data_with_calcs

def calc_historical_volatility(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price: str  = 'Close',
        window:    int  = 20,
        add_col:   bool = False,
        plot:      bool = True,
        style:     str  = 'dark_background',
        figsize:   tuple[int] | None = None,
        color:     str  = 'c'
) -> pd.DataFrame:
    """
        Calculates the historical volatility of a ticker and shows a plot,
        can also get the columns of the data obtained.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - window: int=20
            Window to use for calculations.
        - add_col: bool=False
            If to add columns of the calculations to the source data ticker.
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - color: str='c':
            Color of the Volatility line.

        Example use
        ---
        `data_with_calcs = aa.calc_historical_volatility(data, 'SPY', add_col=True)`
    """

    data_to_use = data.loc[start:end][ticker][use_price]

    log_return = np.log(data_to_use / data_to_use.shift(1))
    volatility = log_return.rolling(window).std() * np.sqrt(252)

    # Prepare data to be returned
    df = pd.DataFrame()
    df['Log Return'] = log_return
    df['Volatility'] = volatility

    if add_col:
        df.columns = pd.MultiIndex.from_product([[f'{ticker}'], df.columns])
        df = pd.concat([data, df], axis=1)

    if plot:
        # Prepate data to plot
        data_to_plot = volatility
        date_format = '%Y-%m-%d'
        if data_to_plot.index.name == 'Datetime':
            date_format = '%Y-%m-%d %H:%M'
        data_to_plot.index = data_to_plot.index.strftime(date_format)

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} Historical Volatility', size=18)

            plt.plot(data_to_plot, color=color, label='Volatility')
            plt.axhline(data_to_plot.mean(), color='y', linestyle='--', label='Average')

            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.xticks(np.arange(len(data_to_plot),
                                step=max(len(data_to_plot) // 10, 1)),
                       size=7)
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Volatility')
            plt.show()

    return df

# data_with_calcs = calc_historical_volatility(data_with_calcs, 'SPY', add_col=True)
# data_with_calcs

def calc_bollinger_bands(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price: str   = 'Close',
        window:    int   = 20,
        num_std:   float = 2.0,
        add_col:   bool  = False,
        plot:      bool  = True,
        style:     str   = 'dark_background',
        figsize:   tuple[int] | None = None,
        color:     str   = 'c'
) -> pd.DataFrame:
    """
        Calculates the Bollinger Bands of a ticker and shows a plot,
        can also get the columns of the data obtained.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - window: int=20
            Window to use for calculations.
        - num_std: float=2.0
            Number of standard deviations for the upper and lower bands.
        - add_col: bool=False
            If to add columns of the calculations to the source data ticker.
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)
        - color: str='c':
            Color of the Price line.

        Example use
        ---
        `data_with_calcs = aa.calc_bollinger_bands(data, 'SPY', add_col=True)`
    """

    data_to_use = data.loc[start:end][ticker][use_price]

    std = data_to_use.rolling(window).std()

    middle_band = data_to_use.rolling(window).mean()
    upper_band  = middle_band + num_std * std
    lower_band  = middle_band - num_std * std

    # Prepare data to be returned
    df = pd.DataFrame()
    df['Upper Band']  = upper_band
    df['Middle Band'] = middle_band
    df['Lower Band']  = lower_band

    if add_col:
        df.columns = pd.MultiIndex.from_product([[f'{ticker}'], df.columns])
        df = pd.concat([data, df], axis=1)

    if plot:
        # Prepate data to plot
        data_to_plot = data_to_use
        date_format = '%Y-%m-%d'
        if data_to_plot.index.name == 'Datetime':
            date_format = '%Y-%m-%d %H:%M'
        data_to_plot.index = data_to_plot.index.strftime(date_format)

        upper_band .index = upper_band .index.strftime(date_format)
        middle_band.index = middle_band.index.strftime(date_format)
        lower_band .index = lower_band .index.strftime(date_format)

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} Bollinger Bands', size=18)

            plt.plot(data_to_plot, color=color, label=f'{use_price} Price')
            plt.plot(upper_band , color='r', alpha=0.7,
                     label=f'Upper  Band ({window}MA + {num_std} STD)')
            plt.plot(middle_band, color='b', alpha=0.7,
                     label=f'Middle Band ({window}MA)')
            plt.plot(lower_band , color='g', alpha=0.7,
                     label=f'Lower  Band ({window}MA - {num_std} STD)')
            plt.fill_between(data_to_plot.index, upper_band, lower_band,
                             color='grey', alpha=0.4)

            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.xticks(np.arange(len(data_to_plot),
                                step=max(len(data_to_plot) // 10, 1)),
                       size=7)
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Price ($)')
            plt.show()

    return df

# data_with_calcs = calc_bollinger_bands(data_with_calcs, 'SPY', add_col=True)
# data_with_calcs

def calc_macd(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price:     str  = 'Close',
        short_window:  int  = 12,
        long_window:   int  = 26,
        signal_window: int  = 9,
        add_col:       bool = False,
        plot:          bool = True,
        style:         str  = 'dark_background',
        figsize:       tuple[int] | None = None
) -> pd.DataFrame:
    """
        Calculates the Moving Average Convergence Divergence (MACD) of a ticker and shows a plot,
        can also get the columns of the data obtained.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - short_window: int=12
            Window to use for the short term exponential moving average calculation.
        - long_window: int=26
            Window to use for the long term exponential moving average calculation.
        - signal_window: int=9
            Window to use for the signal calculation.
        - add_col: bool=False
            If to add columns of the calculations to the source data ticker.
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)

        Example use
        ---
        `data_with_calcs = aa.calc_macd(data, 'SPY', add_col=True)`
    """

    data_to_use = data.loc[start:end][ticker][use_price]

    short_ema = data_to_use.ewm(span=short_window, adjust=False).mean()
    long_ema = data_to_use.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    macd_histogram = macd - signal

    # Prepare data to be returned
    df = pd.DataFrame()
    df[f'EMA{short_window}'] = short_ema
    df[f'EMA{long_window}'] = long_ema
    df['MACD'] = macd
    df[f'Signal{signal_window}'] = signal
    df['MACD_Histogram'] = macd_histogram

    if add_col:
        df.columns = pd.MultiIndex.from_product([[f'{ticker}'], df.columns])
        df = pd.concat([data, df], axis=1)

    if plot:
        # Prepate data to plot
        date_format = '%Y-%m-%d'
        if macd.index.name == 'Datetime':
            date_format = '%Y-%m-%d %H:%M'
        macd.index = macd.index.strftime(date_format)
        signal.index = signal.index.strftime(date_format)

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} MACD', size=18)

            plt.plot(macd, label='MACD', color='c')
            plt.plot(signal, label='Signal', color='r')
            plt.bar(macd.index, macd_histogram,
                    label='Histogram', color='gray', alpha=0.8)

            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.xticks(np.arange(len(macd),
                                step=max(len(macd) // 10, 1)),
                    size=7)
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('MACD')
            plt.show()

    return df

# data_with_calcs = calc_macd(data_with_calcs, 'SPY', add_col=True)
# data_with_calcs

def monthly_returns(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price: str  = 'Close',
        as_pct:    bool = True,
        plot:      bool = True,
        style:     str  = 'dark_background',
        figsize:   tuple[int] | None = None
) -> pd.DataFrame:
    """
        Calculates the Mean Monthly Returns of a ticker and shows a plot.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - as_pct: bool=True
            If True, values are expressed as percentages (e.g. 1.23 (%)),
            if False, as decimals (e.g. 0.0123).
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)

        Example use
        ---
        `monthly_ret = aa.monthly_returns(data, 'SPY')`
    """

    data_to_use = data.loc[start:end][ticker][use_price]
    returns = data_to_use.resample('M').ffill().pct_change()

    if as_pct:
        returns *= 100
        y_axis_label = '%'
    else:
        y_axis_label = 'decimal'

    mean_ret = returns.groupby(returns.index.month).mean().dropna()

    # Prepare data to be returned
    df = pd.DataFrame()
    df['Mean Monthly Return'] = mean_ret
    df.index.name = 'Month'

    if plot:
        # Prepate data to plot
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        map_month = {i: month for i, month in zip(range(1, 13), months)}
        mean_ret.index = mean_ret.index.map(map_month)

        color = ['r' if i < 0 else 'g' for i in mean_ret]

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} Average Monthly Returns', size=18)

            plt.bar(mean_ret.index,
                    mean_ret,
                    color=color,
                    edgecolor='w')
            plt.axhline(0, linewidth=1)
            plt.axhline(mean_ret.mean(),
                        color='y',
                        linestyle='--',
                        label='Average')

            plt.xticks(rotation=0)
            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.legend()
            plt.xlabel('Month')
            plt.ylabel(f'Average Return ({y_axis_label})')
            plt.show()

    return df

# monthly_ret = monthly_returns(data, 'SPY')
# monthly_ret

def hourly_returns(
        data:   pd.DataFrame,
        ticker: str,
        start:  str | None = None,
        end:    str | None = None,
        *,
        use_price: str  = 'Close',
        as_pct:    bool = True,
        plot:      bool = True,
        style:     str  = 'dark_background',
        figsize:   tuple[int] | None = None
) -> pd.DataFrame:
    """
        Calculates the Mean Hourly Returns of a ticker and shows a plot.
        #### return pd.DataFrame

        Params
        ---
        - data: pd.DataFrame
            Takes price data of interval '60m' or shorter.
        - ticker: str
            The ticker to use.
        - start: str | None=None
            The start date formatted as 'YYYY-MM-DD', inclusive.
        - end: str | None=None
            The end date formatted as 'YYYY-MM-DD', inclusive.
        - use_price: str='Close'
            The price column to use.
        - as_pct: bool=True
            If True, values are expressed as percentages (e.g. 1.23 (%)),
            if False, as decimals (e.g. 0.0123).
        - plot: bool=True
            If to show the plot.
        - style: str='dark_background'
            Style of the plot, check available styles with `plt.style.available`
        - figsize: tuple[int] | None=None
            Width and height of the plot,
            if None, defaults to (16, 6)

        Example use
        ---
        `hourly_ret = aa.hourly_returns(data, 'SPY')`
    """

    data_to_use = data.loc[start:end][ticker][use_price]
    returns = data_to_use.pct_change()

    if as_pct:
        returns *= 100
        y_axis_label = '%'
    else:
        y_axis_label = 'decimal'

    mean_ret = returns.groupby(returns.index.hour).mean()
    mean_ret = mean_ret.loc[9:15]

    # Prepare data to be returned
    df = pd.DataFrame()
    df['Mean Hourly Return'] = mean_ret
    df.index.name = 'Hour'

    if plot:
        color = ['r' if i < 0 else 'g' for i in mean_ret]

        if figsize is None:
            figsize = (16, 6)

        # Plot
        with plt.style.context(style):
            plt.figure(figsize=figsize)
            plt.title(f'{ticker} Average Hourly Returns', size=18)

            plt.bar(mean_ret.index,
                    mean_ret,
                    color=color,
                    edgecolor='w')
            plt.axhline(0, linewidth=1)
            plt.axhline(mean_ret.mean(),
                        color='y',
                        linestyle='--',
                        label='Average')

            # plt.xticks(rotation=0)
            plt.grid(which='major', color='grey', zorder=0, linestyle=':')
            plt.legend()
            plt.xlabel('Hour')
            plt.ylabel(f'Average Return ({y_axis_label})')
            plt.show()

    return df

# tickers = ['SPY', 'AAPL', 'TSLA', 'KO']
# data = download_data(tickers, '2022-07-01', '2024-05-01', '60m')
# hourly_ret = hourly_returns(data, 'SPY')
# hourly_ret.head(50)